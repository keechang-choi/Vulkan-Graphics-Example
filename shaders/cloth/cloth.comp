
#version 450


struct VertexIn{
	vec4 pos; // w as skinIndex
	vec4 normal; // w not used
	vec4 color;  
	vec4 joint0;
	vec4 weight0;
	vec4 tangent;
	vec2 uv;
};

struct VertexOut{
	vec4 pos; // w as skinIndex
	vec4 normal; // w not used
	vec4 color;
	vec4 tangent;
	vec2 uv;
};

struct MeshMatrices{
	mat4 nodeMatrix;
	mat4 jointMatrices[64];
	vec4 jointCount;
};

struct ParticleCalculate{
	dvec4 prevPos;
	dvec4 pos;
	dvec4 vel;
	dvec4 corr;	
};

struct ParticleRender{
	vec4 pos;
	vec4 normal;
	vec2 uv;
};

struct DistConstraint{
	uvec2 constIds;
	float restLength;
};

layout ( push_constant ) uniform PushConstants{
	uvec2 constraintInfo;
} pushConstants;

layout (std140, set = 0, binding = 0) uniform ComputeUbo
{
	vec4 clickData;
	vec4 gravity;
	ivec2 particleCount;
	float dt;
	float stiffness;
	float alpha;
	float jacobiScale;
	float thickness;
	float radius;
	float friction;
	uint numSubsteps;
} computeUbo;

layout (std430, set = 1, binding = 0) readonly buffer VertexInSSBO{
	VertexIn verticesIn[ ];
};

layout (std430, set = 1, binding = 1) readonly buffer IndexInSSBO{
	uint indicesIn[ ];
};

layout (set = 2, binding = 0) uniform ModelUbo 
{
	mat4 modelMatrix;
	vec4 modelColor;
} modelUbo;


layout (std430, set = 3, binding = 0) readonly buffer SkinSSBO{
	MeshMatrices meshMatrices[ ];
};
// animation output, used in cloth calculation
layout (std430, set = 3, binding = 1) readonly buffer VertexOutSSBO{
	VertexOut verticesOut[ ];
};

layout (std430, set = 4, binding = 0) buffer CalculateParticleSSBO{
	ParticleCalculate calculateParticles[ ];
};

layout (std430, set = 4, binding = 1) buffer RenderParticleSSBO{
	ParticleRender renderParticles[ ];
};

layout (std430, set = 4, binding = 2) readonly buffer PrevCalculateParticleSSBO{
	ParticleCalculate prevCalculateParticles[ ];
};


layout (std430, set = 5, binding = 0) buffer DistConstraintSSBO{
	DistConstraint distConstraints[ ];
};

layout (constant_id = 0) const int SHARED_DATA_SIZE = 512;
layout (constant_id = 1) const int COMPUTE_TYPE = 0;
layout (local_size_x_id = 2) in;
layout (local_size_y_id = 3) in;
layout (local_size_z_id = 4) in;

const uint kInitializeParticles = 0;
const uint kInitializeConstraints = 1;
const uint kIntegrate = 2;
const uint kSolveCollision = 3;
const uint kSolveDistanceConstraintsGauss = 4;
const uint kSolveDistanceConstraintsJacobi = 5;
const uint kAddCorrections = 6;
const uint kUpdateVel = 7;
const uint kUpdateMesh = 8;

void initializeParticles(in uint xIdx){
	if (xIdx >= indicesIn.length()) {
		return;	
	}
	renderParticles[xIdx].uv = verticesIn[indicesIn[xIdx]].uv;
	// TODO: optimize
	if (xIdx >= calculateParticles.length()){
		return;
	}
	mat4 initialTransform = modelUbo.modelMatrix;
	double invMass = calculateParticles[xIdx].pos.w;
	calculateParticles[xIdx].pos = initialTransform * vec4(verticesIn[xIdx].pos.xyz, 1.0);
	calculateParticles[xIdx].pos.w = invMass;
	calculateParticles[xIdx].vel = dvec4(0.0);
}

void initializeConstraints(in uint xIdx){
	if (xIdx >= distConstraints.length()) {
		return;	
	}
	uint id0 = distConstraints[xIdx].constIds.x;
	uint id1 = distConstraints[xIdx].constIds.y;
	distConstraints[xIdx].restLength = float(distance(
		calculateParticles[id0].pos.xyz, 
		calculateParticles[id1].pos.xyz));
}

void integrate(in uint xIdx){
	if (xIdx >= calculateParticles.length()) {
		return;	
	}
	double sdt = computeUbo.dt / double(computeUbo.numSubsteps);
	calculateParticles[xIdx].prevPos = prevCalculateParticles[xIdx].pos;
	calculateParticles[xIdx].vel = prevCalculateParticles[xIdx].vel + computeUbo.gravity * sdt;
	calculateParticles[xIdx].pos = prevCalculateParticles[xIdx].pos + calculateParticles[xIdx].vel * sdt;
	calculateParticles[xIdx].corr = dvec4(0.0);

	// floor collision
	if(calculateParticles[xIdx].pos.y > -computeUbo.thickness){
		dvec3 p = calculateParticles[xIdx].pos.xyz * (1.0 - computeUbo.friction) + calculateParticles[xIdx].prevPos.xyz * computeUbo.friction;
		calculateParticles[xIdx].pos.xyz = dvec3(p.x, -computeUbo.thickness, p.z);
		// TODO: temp vel update
		calculateParticles[xIdx].vel.xyz = dvec3(0.0);
	}
}

void solveCollision(in uint xIdx, in uint yIdx){
	if (xIdx >= calculateParticles.length()) {
		return;	
	}
	if(yIdx >= verticesOut.length()){
		return;
	}

	double d = distance(verticesOut[yIdx].pos.xyz, calculateParticles[xIdx].pos.xyz);
	if(d < computeUbo.radius + computeUbo.thickness){
		dvec3 p = calculateParticles[xIdx].pos.xyz * (1.0 - computeUbo.friction) + calculateParticles[xIdx].prevPos.xyz * computeUbo.friction;
		dvec3 r = normalize(p - verticesOut[yIdx].pos.xyz);
		calculateParticles[xIdx].pos.xyz = verticesOut[yIdx].pos.xyz + r * (computeUbo.radius + computeUbo.thickness);
		// TODO: temp vel update
		calculateParticles[xIdx].vel.xyz = dvec3(0.0);
	}
}

void calculateDistanceCorrection(in dvec4 pos0, in dvec4 pos1, in double l0, out dvec3 corr0, out dvec3 corr1){
	// w as invMass
	corr0 = vec3(0.0);
	corr1 = vec3(0.0);
	double w0 = pos0.w;
	double w1 = pos1.w;
	double w = w0 + w1;
	if(w == 0.0){
		return;
	}
	dvec3 p0 = pos0.xyz;
	dvec3 p1 = pos1.xyz;
	dvec3 d = p1 - p0;
	double l = length(d);
	if(l == 0.0){
		return;
	}
	dvec3 n = normalize(d);
	dvec3 dP = n * (l - l0) / w;
	corr0 = computeUbo.stiffness * w0 * dP;
	corr1 = computeUbo.stiffness * -w1 * dP;
}

void solveDistanceConstraintsGauss(in uint xIdx){
	uint firstConstraintIdx = pushConstants.constraintInfo.x;
	uint constraintSize = pushConstants.constraintInfo.y;
	if(xIdx >= constraintSize){
		return;
	}
	uint constraintIdx = firstConstraintIdx + xIdx;
	
	uint id0 = distConstraints[constraintIdx].constIds.x;
	uint id1 = distConstraints[constraintIdx].constIds.y;
	double l0 = distConstraints[constraintIdx].restLength;
	// TODO: different cloth constraints
	dvec3 corr0;
	dvec3 corr1;
	calculateDistanceCorrection(
		calculateParticles[id0].pos, 
		calculateParticles[id1].pos, 
		l0,
		corr0,
		corr1);
	
	calculateParticles[id0].pos += dvec4(corr0, 0.0);
	calculateParticles[id1].pos += dvec4(corr1, 0.0);
}

void solveDistanceConstraintsJacobi(in uint xIdx){
	uint firstConstraintIdx = pushConstants.constraintInfo.x;
	uint constraintSize = pushConstants.constraintInfo.y;
	if(xIdx >= constraintSize){
		return;
	}
	uint constraintIdx = firstConstraintIdx + xIdx;
	
	uint id0 = distConstraints[constraintIdx].constIds.x;
	uint id1 = distConstraints[constraintIdx].constIds.y;
	double l0 = distConstraints[constraintIdx].restLength;
	// TODO: different cloth constraints
	dvec3 corr0;
	dvec3 corr1;
	calculateDistanceCorrection(
		calculateParticles[id0].pos, 
		calculateParticles[id1].pos, 
		l0,
		corr0,
		corr1);
	
	calculateParticles[id0].corr = dvec4(corr0, 0.0);
	calculateParticles[id1].corr = dvec4(corr1, 0.0);
}

void addCorrections(in uint xIdx){
	if(xIdx >= calculateParticles.length()){
		return;
	}
	calculateParticles[xIdx].pos += calculateParticles[xIdx].corr * computeUbo.jacobiScale;
}

void updateVel(in uint xIdx){
	if(xIdx >= calculateParticles.length()){
		return;
	}
	double sdt = computeUbo.dt / double(computeUbo.numSubsteps);
	if(sdt == 0.0){
		// first compute
		calculateParticles[xIdx].vel = dvec4(0.0);
		return;
	}
	calculateParticles[xIdx].vel = (calculateParticles[xIdx].pos - calculateParticles[xIdx].prevPos) / sdt;
}

void updateMesh(in uint xIdx){
	if (xIdx >= indicesIn.length()) {
		return;	
	}
	renderParticles[xIdx].pos = vec4(calculateParticles[indicesIn[xIdx]].pos);
	// TODO: optimize
	if (xIdx >= indicesIn.length()/3) {
		return;	
	}
	vec3 p0 = vec3(calculateParticles[indicesIn[3*xIdx+0]].pos);
	vec3 p1 = vec3(calculateParticles[indicesIn[3*xIdx+1]].pos);
	vec3 p2 = vec3(calculateParticles[indicesIn[3*xIdx+2]].pos);
	vec3 normal = normalize(cross(p1-p0, p2-p0));
	renderParticles[3*xIdx+0].normal = vec4(normal, 0.0);
	renderParticles[3*xIdx+1].normal = vec4(normal, 0.0);
	renderParticles[3*xIdx+2].normal = vec4(normal, 0.0);
}

void main() 
{
	// Current SSBO index
	uint xIdx = gl_GlobalInvocationID.x;
	uint yIdx = gl_GlobalInvocationID.y;
	uint zIdx = gl_GlobalInvocationID.z;

	if(COMPUTE_TYPE == kInitializeParticles){
		initializeParticles(xIdx);
	}else if(COMPUTE_TYPE == kInitializeConstraints){
		initializeConstraints(xIdx);
	}else if(COMPUTE_TYPE == kIntegrate){
		integrate(xIdx);
	}else if(COMPUTE_TYPE == kSolveCollision){
		solveCollision(xIdx, yIdx);
	}else if(COMPUTE_TYPE == kSolveDistanceConstraintsGauss){
		solveDistanceConstraintsGauss(xIdx);
	}else if(COMPUTE_TYPE == kSolveDistanceConstraintsJacobi){
		solveDistanceConstraintsJacobi(xIdx);
	}else if(COMPUTE_TYPE == kAddCorrections){
		//TODO: add after checking Gauss-Seidel solver
		// addCorrections(xIdx);
	}else if(COMPUTE_TYPE == kUpdateVel){
		updateVel(xIdx);
	}else if(COMPUTE_TYPE == kUpdateMesh){
		updateMesh(xIdx);
	}
}