
#version 450


struct VertexIn{
	vec4 pos; // w as skinIndex
	vec4 normal; // w not used
	vec4 color;  
	vec4 joint0;
	vec4 weight0;
	vec4 tangent;
	vec2 uv;
};

struct VertexOut{
	vec4 pos; // w as skinIndex
	vec4 normal; // w not used
	vec4 color;
	vec4 tangent;
	vec2 uv;
};

struct MeshMatrices{
	mat4 nodeMatrix;
	mat4 jointMatrices[64];
	vec4 jointCount;
};

struct ParticleCalculate{
	vec4 prevPos;
	vec4 pos;
	vec4 vel;
	vec4 corr;	
};

struct ParticleRender{
	vec4 pos;
	vec4 normal;
	vec2 uv;
};

struct DistConstraint{
	ivec2 constIds;
	float restLength;
};

layout ( push_constant ) uniform PushConstants{
	ivec2 constraintInfo;
} pushConstants;

layout (std140, set = 0, binding = 0) uniform ComputeUbo
{
	vec4 clickData;
	vec4 gravity;
	ivec2 particleCount;
	float dt;
	float stiffness;
	float alpha;
	float jacobiScale;
	float thickness;
	float radius;
	float friction;
	bool solveType;
} computeUbo;

layout (std430, set = 1, binding = 0) readonly buffer VertexInSSBO{
	VertexIn verticesIn[ ];
};

layout (std430, set = 1, binding = 1) readonly buffer IndexInSSBO{
	uint indicesIn[ ];
};

layout (set = 2, binding = 0) uniform ModelUbo 
{
	mat4 modelMatrix;
	vec4 modelColor;
} modelUbo;


layout (std430, set = 3, binding = 0) readonly buffer SkinSSBO{
	MeshMatrices meshMatrices[ ];
};
// animation output, used in cloth calculation
layout (std430, set = 3, binding = 1) readonly buffer VertexOutSSBO{
	VertexOut verticesOut[ ];
};

layout (std430, set = 4, binding = 0) buffer CalculateParticleSSBO{
	ParticleCalculate calculateParticles[ ];
};

layout (std430, set = 4, binding = 1) buffer RenderParticleSSBO{
	ParticleRender renderParticles[ ];
};

layout (std430, set = 4, binding = 2) readonly buffer PrevCalculateParticleSSBO{
	ParticleCalculate prevCalculateParticles[ ];
};


layout (std430, set = 5, binding = 0) buffer DistConstraintSSBO{
	DistConstraint distConstraints[ ];
};

layout (constant_id = 0) const int SHARED_DATA_SIZE = 512;
layout (constant_id = 1) const int COMPUTE_TYPE = 0;
layout (local_size_x_id = 2) in;
layout (local_size_y_id = 3) in;
layout (local_size_z_id = 4) in;

const uint kInitializeParticles = 0;
const uint kInitializeConstraint = 1;
const uint kIntegrate = 2;
const uint kSolveCollision = 3;
const uint kSolveDistanceConstraintsGauss = 4;
const uint kSolveDistanceConstraintsJacobi = 5;
const uint kAddCorrections = 6;
const uint kUpdateVel = 7;
const uint kUpdateMesh = 8;

void initializeParticles(in uint xIdx){
	if (xIdx >= indicesIn.length()) {
		return;	
	}
	renderParticles[xIdx].uv = verticesIn[indicesIn[xIdx]].uv;
	// TODO: optimize
	if (xIdx >= calculateParticles.length()){
		return;
	}
	mat4 initialTransform = modelUbo.modelMatrix;
	calculateParticles[xIdx].pos = initialTransform * vec4(verticesIn[xIdx].pos.xyz, 1.0);
	calculateParticles[xIdx].vel = vec4(0.0);
}

void integrate(in uint xIdx){
	if (xIdx >= calculateParticles.length()) {
		return;	
	}
	calculateParticles[xIdx].prevPos = calculateParticles[xIdx].pos;
	calculateParticles[xIdx].vel = prevCalculateParticles[xIdx].vel + computeUbo.gravity * computeUbo.dt;
	calculateParticles[xIdx].pos = prevCalculateParticles[xIdx].pos + calculateParticles[xIdx].vel * computeUbo.dt;

	// floor collision
	if(calculateParticles[xIdx].pos.y > -computeUbo.thickness){
		vec3 p = calculateParticles[xIdx].pos.xyz * (1.0 - computeUbo.friction) + calculateParticles[xIdx].prevPos.xyz * computeUbo.friction;
		calculateParticles[xIdx].pos.xyz = vec3(p.x, -computeUbo.thickness, p.z);
		// TODO: temp vel update
		calculateParticles[xIdx].vel.xyz = vec3(0.0);
	}
}

void solveCollision(in uint xIdx, in uint yIdx){
	if (xIdx >= calculateParticles.length()) {
		return;	
	}
	if(yIdx >= verticesOut.length()){
		return;
	}

	float d = distance(verticesOut[yIdx].pos.xyz, calculateParticles[xIdx].pos.xyz);
	if(d < computeUbo.radius + computeUbo.thickness){
		vec3 p = calculateParticles[xIdx].pos.xyz * (1.0 - computeUbo.friction) + calculateParticles[xIdx].prevPos.xyz * computeUbo.friction;
		vec3 r = normalize(p - verticesOut[yIdx].pos.xyz);
		calculateParticles[xIdx].pos.xyz = verticesOut[yIdx].pos.xyz + r * (computeUbo.radius + computeUbo.thickness);
		// TODO: temp vel update
		calculateParticles[xIdx].vel.xyz = vec3(0.0);
	}
}

void updateMesh(in uint xIdx){
	if (xIdx >= indicesIn.length()) {
		return;	
	}
	renderParticles[xIdx].pos = calculateParticles[indicesIn[xIdx]].pos;
	// TODO: optimize
	if (xIdx >= indicesIn.length()/3) {
		return;	
	}
	vec3 p0 = vec3(calculateParticles[indicesIn[3*xIdx+0]].pos);
	vec3 p1 = vec3(calculateParticles[indicesIn[3*xIdx+1]].pos);
	vec3 p2 = vec3(calculateParticles[indicesIn[3*xIdx+2]].pos);
	vec3 normal = normalize(cross(p1-p0, p2-p0));
	renderParticles[3*xIdx+0].normal = vec4(normal, 0.0);
	renderParticles[3*xIdx+1].normal = vec4(normal, 0.0);
	renderParticles[3*xIdx+2].normal = vec4(normal, 0.0);
}

void main() 
{
	// Current SSBO index
	uint xIdx = gl_GlobalInvocationID.x;
	uint yIdx = gl_GlobalInvocationID.y;
	uint zIdx = gl_GlobalInvocationID.z;

	if(COMPUTE_TYPE == kInitializeParticles){
		initializeParticles(xIdx);
	}// TODO: initialize constraints
	else if(COMPUTE_TYPE == kIntegrate){
		integrate(xIdx);
	}else if(COMPUTE_TYPE == kSolveCollision){
		solveCollision(xIdx, yIdx);
	}else if(COMPUTE_TYPE == kUpdateMesh){
	// TODO: update mesh
		updateMesh(xIdx);
	}
}